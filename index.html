<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Music Studio — Single File</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    :root{--bg:#0f172a;--panel:#0b1220;--muted:#94a3b8;--accent:#6366f1;--accent-2:#f59e0b}
    html,body{height:100%;}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial; background:var(--bg); color:#e6eef8; margin:0;padding:28px}
    .container{max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(100,116,139,.12); padding:20px; border-radius:12px}
    .title{font-size:28px;font-weight:700;color:#fff;margin-bottom:6px}
    .subtitle{color:var(--muted);margin-bottom:18px}
    .grid-cell{width:28px;height:28px;border-radius:6px;border:1px solid rgba(100,116,139,.16);display:inline-block;margin-right:6px;transition:background-color .12s,transform .08s}
    .grid-row{display:flex;align-items:center;margin-bottom:8px}
    .grid-label{width:84px;text-align:right;margin-right:12px;color:var(--muted);font-size:13px}
    .grid-cell.active{background:var(--accent);border-color:#4338ca}
    .grid-cell.current{box-shadow:0 0 0 3px rgba(234,179,8,0.12);border-color:var(--accent-2)}
    .controls{display:flex;gap:12px;align-items:center}
    input[type=range]{accent-color:var(--accent)}
    .transparent-input{background:transparent;border:none;color:inherit;text-align:center}
    .btn{padding:8px 12px;border-radius:10px;font-weight:600}
    .btn-primary{background:linear-gradient(180deg,var(--accent),#4f46e5);color:white}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    details summary{cursor:pointer;outline:none}
    .small{font-size:13px;color:var(--muted)}
    .tooltip{position:relative}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="flex items-start justify-between">
        <div>
          <div class="title">Web Music Studio</div>
          <div class="subtitle">Sequencer with synths, mixer, WAV export, autosave, swing, and accessible controls.</div>
        </div>
        <div class="small">v1.3 • Single file</div>
      </div>

      <!-- Master Controls -->
      <div class="card mt-4">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div class="controls">
            <button id="playBtn" class="btn btn-primary" aria-label="Play" title="Play (Space)">Play</button>
            <button id="stopBtn" class="btn btn-ghost" aria-label="Stop" title="Stop">Stop</button>

            <label class="small ml-2" for="bpmInput">BPM</label>
            <input id="bpmInput" type="number" min="40" max="240" value="120" class="transparent-input" aria-label="BPM input">
            <input id="bpmSlider" type="range" min="40" max="240" value="120" aria-label="BPM slider">

            <label class="small ml-3">Swing</label>
            <input id="swingSlider" type="range" min="0" max="60" value="0" aria-label="Swing slider" title="Adds a small timing shuffle in percent">

            <label class="small ml-3">Loops</label>
            <input id="songLengthInput" type="number" min="1" max="160" value="4" class="transparent-input" aria-label="Song length in loops">
          </div>

          <div class="flex items-center gap-3">
            <input id="trackNameInput" type="text" placeholder="Track name" aria-label="Track name" class="transparent-input" style="border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:inherit">
            <button id="recordBtn" class="btn btn-ghost" aria-label="Export WAV">Export WAV</button>
            <button id="saveBtn" class="btn btn-primary" aria-label="Save track">Save</button>
            <button id="loadBtn" class="btn btn-ghost" aria-label="Load track">Load</button>
          </div>
        </div>
      </div>

      <!-- Instruments -->
      <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
        <details open class="card">
          <summary class="text-xl font-semibold">Drum Machine</summary>
          <div class="mt-3">
            <div class="flex items-center justify-between">
              <div class="controls">
                <label class="small">Volume</label>
                <input id="drumVol" type="range" min="0" max="1" step="0.01" value="0.8" aria-label="Drum volume">
                <button id="clearDrum" class="btn btn-ghost">Clear</button>
              </div>
              <div class="controls">
                <label class="small">Kit</label>
                <select id="drumKitSelect" aria-label="Drum kit selection" class="small">
                  <option value="electro">Electro</option>
                  <option value="acoustic">Acoustic</option>
                </select>
              </div>
            </div>
            <div id="drumGrid" class="mt-3"></div>
          </div>
        </details>

        <details open class="card">
          <summary class="text-xl font-semibold">Piano Roll</summary>
          <div class="mt-3">
            <div class="flex items-center justify-between">
              <div class="controls">
                <label class="small">Volume</label>
                <input id="pianoVol" type="range" min="0" max="1" step="0.01" value="0.6" aria-label="Piano volume">
                <button id="clearPiano" class="btn btn-ghost">Clear</button>
              </div>
              <div class="controls">
                <label class="small">Wave</label>
                <select id="pianoWave" aria-label="Piano waveform" class="small">
                  <option>triangle</option>
                  <option>sine</option>
                  <option>sawtooth</option>
                </select>
              </div>
            </div>
            <div id="pianoGrid" class="mt-3"></div>
          </div>
        </details>

        <details open class="card">
          <summary class="text-xl font-semibold">Bass Line</summary>
          <div class="mt-3">
            <div class="flex items-center justify-between">
              <div class="controls">
                <label class="small">Volume</label>
                <input id="bassVol" type="range" min="0" max="1" step="0.01" value="0.7" aria-label="Bass volume">
                <button id="clearBass" class="btn btn-ghost">Clear</button>
              </div>
              <div class="controls">
                <label class="small">Wave</label>
                <select id="bassWave" aria-label="Bass waveform" class="small">
                  <option>sawtooth</option>
                  <option>square</option>
                  <option>triangle</option>
                </select>
              </div>
            </div>
            <div id="bassGrid" class="mt-3"></div>
          </div>
        </details>

        <details open class="card">
          <summary class="text-xl font-semibold">Guitar</summary>
          <div class="mt-3">
            <div class="flex items-center justify-between">
              <div class="controls">
                <label class="small">Volume</label>
                <input id="guitarVol" type="range" min="0" max="1" step="0.01" value="0.5" aria-label="Guitar volume">
                <button id="clearGuitar" class="btn btn-ghost">Clear</button>
              </div>
              <div class="controls">
                <label class="small">Wave</label>
                <select id="guitarWave" aria-label="Guitar waveform" class="small">
                  <option value="custom_guitar">Plucked</option>
                  <option>triangle</option>
                </select>
              </div>
            </div>
            <div id="guitarGrid" class="mt-3"></div>
          </div>
        </details>
      </div>

      <!-- Mixer -->
      <div class="card mt-6">
        <div class="flex items-center justify-between">
          <div>
            <h3 class="font-semibold">Mixer</h3>
            <div class="small">Pan and volume per instrument. Reverb wet mix below.</div>
          </div>
          <div class="flex gap-6 items-center">
            <div class="flex flex-col items-center small">
              <div>Drums</div>
              <input id="mixerDrum" type="range" min="0" max="1" step="0.01" value="0.8" aria-label="Drum mixer volume">
              <input id="panDrum" type="range" min="-1" max="1" step="0.01" value="0" aria-label="Drum pan">
            </div>
            <div class="flex flex-col items-center small">
              <div>Piano</div>
              <input id="mixerPiano" type="range" min="0" max="1" step="0.01" value="0.6" aria-label="Piano mixer volume">
              <input id="panPiano" type="range" min="-1" max="1" step="0.01" value="0" aria-label="Piano pan">
            </div>
            <div class="flex flex-col items-center small">
              <div>Bass</div>
              <input id="mixerBass" type="range" min="0" max="1" step="0.01" value="0.7" aria-label="Bass mixer volume">
              <input id="panBass" type="range" min="-1" max="1" step="0.01" value="0" aria-label="Bass pan">
            </div>
            <div class="flex flex-col items-center small">
              <div>Guitar</div>
              <input id="mixerGuitar" type="range" min="0" max="1" step="0.01" value="0.5" aria-label="Guitar mixer volume">
              <input id="panGuitar" type="range" min="-1" max="1" step="0.01" value="0" aria-label="Guitar pan">
            </div>
            <div class="flex flex-col items-center small">
              <div>Reverb</div>
              <input id="mixerReverb" type="range" min="0" max="1" step="0.01" value="0.25" aria-label="Reverb wet mix">
            </div>
          </div>
        </div>
      </div>

      <div id="statusMsg" class="small mt-4 text-green-400" role="status" aria-live="polite"></div>

    </div>
  </div>

  <script>
    // Single-file sequencer improvements:
    // - Reuse AudioContext. Do not close when stopping to avoid latency.
    // - Debounced BPM changes.
    // - Swing timing applied per step.
    // - Pan support using StereoPannerNode.
    // - Autosave on change.

    // --- State ---
    let audioCtx = null;
    const totalSteps = 16;
    let bpm = 120;
    let songLength = 4;
    let isPlaying = false;
    let songStep = 0;
    let nextLoopTime = 0;
    let scheduleTimer = null;
    let swing = 0; // percentage 0-60

    // Instrument patterns
    const drumPattern = Array(4).fill(null).map(()=>Array(totalSteps).fill(false));
    const pianoPattern = Array(12).fill(null).map(()=>Array(totalSteps).fill(false));
    const bassPattern = Array(8).fill(null).map(()=>Array(totalSteps).fill(false));
    const guitarPattern = Array(8).fill(null).map(()=>Array(totalSteps).fill(false));

    // Nodes containers for live playback
    const nodes = {
      drum: {gain:null, pan:null},
      piano: {gain:null, pan:null},
      bass: {gain:null, pan:null},
      guitar: {gain:null, pan:null},
      reverb: {wet:null}
    };

    // Note data
    const noteFrequencies = { C2:65.41, 'C#2':69.30, D2:73.42, 'D#2':77.78, E2:82.41, F2:87.31, 'F#2':92.50, G2:98.00, 'G#2':103.83, A2:110.00, 'A#2':116.54, B2:123.47, C3:130.81, 'C#3':138.59, D3:146.83, 'D#3':155.56, E3:164.81, F3:174.61, 'F#3':185.00, G3:196.00, 'G#3':207.65, A3:220.00, 'A#3':233.08, B3:246.94, C4:261.63, 'C#4':277.18, D4:293.66, 'D#4':311.13, E4:329.63, F4:349.23, 'F#4':369.99, G4:392.00, 'G#4':415.30, A4:440.00, 'A#4':466.16, B4:493.88, C5:523.25 };
    const noteNames = Object.keys(noteFrequencies);

    // --- Utilities ---
    function showMessage(msg, type='success', ms=2500){
      const el = document.getElementById('statusMsg');
      el.textContent = msg;
      el.className = type==='error' ? 'small mt-4 text-red-400' : 'small mt-4 text-green-400';
      setTimeout(()=>{ el.textContent=''; }, ms);
    }

    function ensureAudioContext(){
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // master chain
        const master = audioCtx.createGain(); master.gain.value = 0.9; master.connect(audioCtx.destination);
        // reverb
        const convolver = audioCtx.createConvolver();
        convolver.buffer = createReverbImpulseResponse(audioCtx);
        const reverbGain = audioCtx.createGain(); reverbGain.gain.value = parseFloat(document.getElementById('mixerReverb').value);
        convolver.connect(reverbGain).connect(master);
        nodes.reverb.wet = reverbGain;

        // create per-instrument nodes
        ['drum','piano','bass','guitar'].forEach(name=>{
          const g = audioCtx.createGain(); g.gain.value = 1; g.connect(master);
          const p = audioCtx.createStereoPanner(); p.pan.value = 0; p.connect(g);
          // also route to reverb
          const g2 = audioCtx.createGain(); g2.gain.value = 1; g2.connect(convolver);
          const p2 = audioCtx.createStereoPanner(); p2.pan.value = 0; p2.connect(g2);
          // final wiring: source -> p -> g -> master
          nodes[name].gain = g;
          nodes[name].pan = p;
          // we will connect sources to p, and reverb connections to convolver via g2/p2 convenience from playback functions
        });
      }
    }

    function createReverbImpulseResponse(ctx, duration=2){
      const rate = ctx.sampleRate; const length = rate*duration; const impulse = ctx.createBuffer(2,length,rate);
      for(let ch=0;ch<2;ch++){ const data = impulse.getChannelData(ch); for(let i=0;i<length;i++){ data[i] = (Math.random()*2-1)*Math.pow(1-i/length,3); }}
      return impulse;
    }

    // --- Tone Generators ---
    function playSynthNote(frequency, waveType, duration, destGainNode, when){
      if(!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      if(waveType==='custom_guitar'){
        const real = new Float32Array([0,0.7,0.4,0.25,0.12]); const imag = new Float32Array(real.length); const pw = audioCtx.createPeriodicWave(real,imag); osc.setPeriodicWave(pw);
      } else { osc.type = waveType; }
      osc.frequency.setValueAtTime(frequency, when);
      gain.gain.setValueAtTime(0, when);
      gain.gain.linearRampToValueAtTime(1, when+0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, when+duration);
      osc.connect(gain).connect(destGainNode);
      osc.start(when); osc.stop(when+duration+0.05);
    }

    function playKick(destGainNode, when){
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type = 'sine'; o.frequency.setValueAtTime(150, when); o.frequency.exponentialRampToValueAtTime(0.01, when+0.18);
      g.gain.setValueAtTime(1, when); g.gain.exponentialRampToValueAtTime(0.001, when+0.18);
      o.connect(g).connect(destGainNode); o.start(when); o.stop(when+0.25);
    }

    function playNoiseDrum(destGainNode, when, type){
      const bufferSize = audioCtx.sampleRate * 0.5; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){ data[i] = Math.random()*2-1; }
      const src = audioCtx.createBufferSource(); src.buffer = buffer;
      const f = audioCtx.createBiquadFilter();
      if(type==='snare'){ f.type='highpass'; f.frequency.setValueAtTime(1500, when);} else if(type==='hihat'){ f.type='highpass'; f.frequency.setValueAtTime(8000, when);} else { f.type='highpass'; f.frequency.setValueAtTime(6000, when);}      
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, when); g.gain.linearRampToValueAtTime(type==='crash'?0.6:0.7, when+0.01); g.gain.exponentialRampToValueAtTime(0.001, when + (type==='crash'?1.2:0.15));
      src.connect(f).connect(g).connect(destGainNode);
      src.start(when); src.stop(when+2);
    }

    // --- Sequencer scheduling ---
    function scheduleLoop(){
      if(!audioCtx) return;
      const timePerStep = 60 / bpm / 4;
      const loopDuration = timePerStep * totalSteps;
      const pianoNotes = noteNames.slice(noteNames.indexOf('C4'), noteNames.indexOf('B4')+1);
      const bassNotes = noteNames.slice(noteNames.indexOf('C2'), noteNames.indexOf('G#2')+1);
      const guitarNotes = noteNames.slice(noteNames.indexOf('G3'), noteNames.indexOf('C5')+1);

      // schedule drums
      for(let i=0;i<drumPattern.length;i++){
        for(let j=0;j<totalSteps;j++){
          if(drumPattern[i][j]){
            const stepTime = nextLoopTime + j*timePerStep + swingOffsetForStep(j,timePerStep);
            if(i===3) playKick(nodes.drum.pan, stepTime); else if(i===1) playNoiseDrum(nodes.drum.pan, stepTime,'snare'); else if(i===2) playNoiseDrum(nodes.drum.pan, stepTime,'hihat'); else playNoiseDrum(nodes.drum.pan, stepTime,'crash');
          }
        }
      }

      function scheduleSustained(pattern, map, gainNode, wave){
        for(let r=0;r<pattern.length;r++){
          let c=0; while(c<totalSteps){ if(pattern[r][c]){ let start=c; let end=c; while(end+1<totalSteps && pattern[r][end+1]) end++; const dur = (end-start+1)*timePerStep; const note = map[r] || map[map.length-1]; playSynthNote(noteFrequencies[note], wave, dur, gainNode, nextLoopTime + start*timePerStep + swingOffsetForStep(start,timePerStep)); c=end+1;} else c++; }}
      }

      scheduleSustained(pianoPattern, pianoNotes, nodes.piano.pan, document.getElementById('pianoWave').value);
      scheduleSustained(bassPattern, bassNotes, nodes.bass.pan, document.getElementById('bassWave').value);
      scheduleSustained(guitarPattern, guitarNotes, nodes.guitar.pan, document.getElementById('guitarWave').value);

      nextLoopTime += loopDuration;
      // schedule next call using setTimeout so UI remains responsive
      scheduleTimer = setTimeout(()=>{ if(isPlaying) scheduleLoop(); }, loopDuration*1000 - 20);
    }

    function swingOffsetForStep(step, timePerStep){
      if(!swing) return 0;
      // apply swing to off-beat 2 & 4 subdivisions (steps with odd index)
      if(step % 2 === 1){ return (timePerStep * (swing/100)) / 2; }
      return 0;
    }

    function startSequencer(){
      if(isPlaying) return;
      ensureAudioContext();
      isPlaying = true; songStep = 0; nextLoopTime = audioCtx.currentTime + 0.05; scheduleLoop(); updateUIIntervalStart();
      document.getElementById('playBtn').disabled = true; document.getElementById('stopBtn').disabled = false;
    }

    function stopSequencer(){
      if(!isPlaying) return;
      isPlaying = false; clearTimeout(scheduleTimer); updateUIIntervalStop(); document.querySelectorAll('.grid-cell.current').forEach(c=>c.classList.remove('current'));
      document.getElementById('playBtn').disabled = false; document.getElementById('stopBtn').disabled = true;
    }

    // --- UI rendering ---
    function createGrid(containerId, pattern, labels, cellClass){
      const container = document.getElementById(containerId); container.innerHTML='';
      for(let r=0;r<pattern.length;r++){
        const row = document.createElement('div'); row.className='grid-row';
        const label = document.createElement('div'); label.className='grid-label'; label.textContent = labels[labels.length-1-r]; row.appendChild(label);
        for(let c=0;c<totalSteps;c++){
          const cell = document.createElement('div'); cell.className='grid-cell '+(cellClass||''); cell.tabIndex=0; cell.dataset.row=r; cell.dataset.col=c; cell.setAttribute('role','button'); cell.setAttribute('aria-pressed', pattern[r][c]);
          if(pattern[r][c]) cell.classList.add('active');
          cell.addEventListener('click', ()=>{ pattern[r][c] = !pattern[r][c]; cell.classList.toggle('active'); cell.setAttribute('aria-pressed', pattern[r][c]); autosave(); });
          row.appendChild(cell);
        }
        container.appendChild(row);
      }
    }

    function updateUIStep(){
      const cur = songStep % totalSteps; const prev = (songStep-1+totalSteps)%totalSteps;
      ['drumGrid','pianoGrid','bassGrid','guitarGrid'].forEach(id=>{
        const cells = document.querySelectorAll('#'+id+' .grid-cell');
        cells.forEach(cell=>{
          if(parseInt(cell.dataset.col)===prev) cell.classList.remove('current');
          if(parseInt(cell.dataset.col)===cur) cell.classList.add('current');
        });
      });
      songStep++;
    }

    let uiInterval = null;
    function updateUIIntervalStart(){ const interval = 60000/bpm/4; uiInterval = setInterval(updateUIStep, interval); }
    function updateUIIntervalStop(){ clearInterval(uiInterval); uiInterval = null; }

    // --- Autosave ---
    function autosave(){
      try{
        const data = { bpm, songLength, drumPattern, pianoPattern, bassPattern, guitarPattern, timestamp:new Date().toISOString(), trackName:document.getElementById('trackNameInput').value };
        localStorage.setItem('musicStudio_autosave', JSON.stringify(data));
        // also maintain saved list when user presses Save button
      }catch(e){ console.error('autosave failed',e); }
    }

    function loadAutosave(){
      try{
        const raw = localStorage.getItem('musicStudio_autosave'); if(!raw) return; const data = JSON.parse(raw);
        bpm = data.bpm || bpm; songLength = data.songLength || songLength; document.getElementById('bpmInput').value=bpm; document.getElementById('bpmSlider').value=bpm; document.getElementById('songLengthInput').value=songLength;
        for(let i=0;i<drumPattern.length;i++) drumPattern[i]=data.drumPattern[i]||drumPattern[i]; for(let i=0;i<pianoPattern.length;i++) pianoPattern[i]=data.pianoPattern[i]||pianoPattern[i]; for(let i=0;i<bassPattern.length;i++) bassPattern[i]=data.bassPattern[i]||bassPattern[i]; for(let i=0;i<guitarPattern.length;i++) guitarPattern[i]=data.guitarPattern[i]||guitarPattern[i];
        document.getElementById('trackNameInput').value = data.trackName || '';
      }catch(e){ console.error('load autosave failed',e); }
    }

    // --- Save / Load tracks list ---
    function saveTrack(){
      try{
        const name = document.getElementById('trackNameInput').value || 'Untitled';
        const list = JSON.parse(localStorage.getItem('musicStudioTracks')||'[]');
        list.push({ name, bpm, songLength, drumPattern:drumPattern.map(r=>[...r]), pianoPattern:pianoPattern.map(r=>[...r]), bassPattern:bassPattern.map(r=>[...r]), guitarPattern:guitarPattern.map(r=>[...r]), timestamp:new Date().toISOString() });
        localStorage.setItem('musicStudioTracks', JSON.stringify(list)); showMessage('Saved track.');
      }catch(e){ showMessage('Save error','error'); }
    }

    function loadTrackList(){ const list = JSON.parse(localStorage.getItem('musicStudioTracks')||'[]'); const el = document.getElementById('loadBtn'); if(list.length===0){ showMessage('No saved tracks'); return;} const idx = prompt('Enter track index to load (0..'+(list.length-1)+')'); const i = parseInt(idx); if(isNaN(i)||i<0||i>=list.length) return; applyTrack(list[i]); }

    function applyTrack(data){ stopSequencer(); for(let i=0;i<drumPattern.length;i++) drumPattern[i]=data.drumPattern[i]||drumPattern[i]; for(let i=0;i<pianoPattern.length;i++) pianoPattern[i]=data.pianoPattern[i]||pianoPattern[i]; for(let i=0;i<bassPattern.length;i++) bassPattern[i]=data.bassPattern[i]||bassPattern[i]; for(let i=0;i<guitarPattern.length;i++) guitarPattern[i]=data.guitarPattern[i]||guitarPattern[i]; bpm = data.bpm||bpm; songLength = data.songLength||songLength; document.getElementById('bpmInput').value=bpm; document.getElementById('bpmSlider').value=bpm; document.getElementById('songLengthInput').value=songLength; renderAllGrids(); }

    // --- Rendering helpers ---
    function renderAllGrids(){
      createGrid('drumGrid', drumPattern, ['Crash','Snare','Hi-hat','Kick']);
      createGrid('pianoGrid', pianoPattern, ['C4','B3','A3','G3','F3','E3','D3','C3','B2','A2','G2','F2']);
      createGrid('bassGrid', bassPattern, ['C2','D2','E2','F2','G2','A2','B2','C3']);
      createGrid('guitarGrid', guitarPattern, ['G3','A3','B3','C4','D4','E4','F4','G4']);
    }

    // --- Export WAV (OfflineAudioContext render) ---
    async function exportWav(){
      showMessage('Rendering WAV. This may take a few seconds.');
      ensureAudioContext(); // need audioCtx for sample rate
      const loops = parseInt(document.getElementById('songLengthInput').value) || 4;
      const sampleRate = 44100; const timePerStep = 60/bpm/4; const loopDuration = timePerStep*totalSteps; const duration = loopDuration*loops;
      const offline = new OfflineAudioContext(2, Math.ceil(duration*sampleRate), sampleRate);
      // simple offline render: create identical graph and schedule as in scheduleLoop but using offline audio context

      const dry = offline.createGain(); dry.connect(offline.destination);
      const reverb = offline.createConvolver(); reverb.buffer = createReverbImpulseResponse(offline);
      const reverbGain = offline.createGain(); reverbGain.gain.value = parseFloat(document.getElementById('mixerReverb').value); reverb.connect(reverbGain); reverbGain.connect(offline.destination);

      const offNodes = {};
      ['drum','piano','bass','guitar'].forEach(name=>{ const g = offline.createGain(); g.gain.value = 1; g.connect(dry); const p = offline.createStereoPanner(); p.connect(g); offNodes[name]={gain:g,pan:p}; // connect to reverb
        const g2 = offline.createGain(); g2.connect(reverb); const p2 = offline.createStereoPanner(); p2.connect(g2); // plugins not wired to sources directly here
      });

      const pianoNotes = noteNames.slice(noteNames.indexOf('C4'), noteNames.indexOf('B4')+1);
      const bassNotes = noteNames.slice(noteNames.indexOf('C2'), noteNames.indexOf('G#2')+1);
      const guitarNotes = noteNames.slice(noteNames.indexOf('G3'), noteNames.indexOf('C5')+1);

      let currentTime = 0;
      for(let loop=0;loop<loops;loop++){
        // drums
        for(let i=0;i<drumPattern.length;i++){
          for(let j=0;j<totalSteps;j++){
            if(drumPattern[i][j]){
              const t = currentTime + j*timePerStep + swingOffsetForStep(j,timePerStep);
              if(i===3) playKickOffline(offNodes.drum.pan, offline, t); else if(i===1) playNoiseDrumOffline(offNodes.drum.pan, offline, t,'snare'); else if(i===2) playNoiseDrumOffline(offNodes.drum.pan, offline, t,'hihat'); else playNoiseDrumOffline(offNodes.drum.pan, offline, t,'crash');
            }
          }
        }
        function scheduleSustainedOffline(pattern, map, node, wave){ for(let r=0;r<pattern.length;r++){ let c=0; while(c<totalSteps){ if(pattern[r][c]){ let s=c; let e=c; while(e+1<totalSteps && pattern[r][e+1]) e++; const dur=(e-s+1)*timePerStep; const note = map[r]||map[map.length-1]; playSynthNoteOffline(noteFrequencies[note], wave, dur, node, offline, currentTime + s*timePerStep + swingOffsetForStep(s,timePerStep)); c=e+1; } else c++; } }}
        scheduleSustainedOffline(pianoPattern,pianoNotes,offNodes.piano.pan,document.getElementById('pianoWave').value);
        scheduleSustainedOffline(bassPattern,bassNotes,offNodes.bass.pan,document.getElementById('bassWave').value);
        scheduleSustainedOffline(guitarPattern,guitarNotes,offNodes.guitar.pan,document.getElementById('guitarWave').value);
        currentTime += loopDuration;
      }

      const rendered = await offline.startRendering();
      const blob = bufferToWav(rendered);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=(document.getElementById('trackNameInput').value||'track')+'.wav'; a.click(); showMessage('WAV ready.');
    }

    // Offline helper implementations
    function playSynthNoteOffline(freq,wave,dur,gainNode,ctx,when){ const osc = ctx.createOscillator(); const g=ctx.createGain(); if(wave==='custom_guitar'){ const real=new Float32Array([0,0.7,0.4,0.25,0.12]); const imag=new Float32Array(real.length); const pw=ctx.createPeriodicWave(real,imag); osc.setPeriodicWave(pw);} else osc.type=wave; osc.frequency.setValueAtTime(freq,when); g.gain.setValueAtTime(0,when); g.gain.linearRampToValueAtTime(1,when+0.01); g.gain.exponentialRampToValueAtTime(0.001,when+dur); osc.connect(g).connect(gainNode); osc.start(when); osc.stop(when+dur+0.05); }
    function playKickOffline(dest,ctx,when){ const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(150,when); o.frequency.exponentialRampToValueAtTime(0.01,when+0.18); g.gain.setValueAtTime(1,when); g.gain.exponentialRampToValueAtTime(0.001,when+0.18); o.connect(g).connect(dest); o.start(when); o.stop(when+0.25); }
    function playNoiseDrumOffline(dest,ctx,when,type){ const bufferSize = ctx.sampleRate*0.5; const buffer = ctx.createBuffer(1,bufferSize,ctx.sampleRate); const data = buffer.getChannelData(0); for(let i=0;i<bufferSize;i++) data[i]=Math.random()*2-1; const src = ctx.createBufferSource(); src.buffer=buffer; const f=ctx.createBiquadFilter(); if(type==='snare'){ f.type='highpass'; f.frequency.setValueAtTime(1500,when);} else if(type==='hihat'){ f.type='highpass'; f.frequency.setValueAtTime(8000,when);} else { f.type='highpass'; f.frequency.setValueAtTime(6000,when);} const g=ctx.createGain(); g.gain.setValueAtTime(0.0001,when); g.gain.linearRampToValueAtTime(type==='crash'?0.6:0.7,when+0.01); g.gain.exponentialRampToValueAtTime(0.001,when+(type==='crash'?1.2:0.15)); src.connect(f).connect(g).connect(dest); src.start(when); src.stop(when+2); }

    // --- WAV helpers ---
    function bufferToWav(buffer){ const numChannels = buffer.numberOfChannels; const length = buffer.length * numChannels * 2 + 44; const ab = new ArrayBuffer(length); const view = new DataView(ab); let offset=0; function writeStr(s){ for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); } function write32(v){ view.setUint32(offset, v, true); offset+=4 } function write16(v){ view.setUint16(offset, v, true); offset+=2 }
      writeStr('RIFF'); write32(length-8); writeStr('WAVE'); writeStr('fmt '); write32(16); write16(1); write16(numChannels); write32(buffer.sampleRate); write32(buffer.sampleRate * numChannels * 2); write16(numChannels * 2); write16(16); writeStr('data'); write32(buffer.length * numChannels * 2);
      for(let i=0;i<buffer.length;i++){ for(let ch=0;ch<numChannels;ch++){ const sample = Math.max(-1,Math.min(1, buffer.getChannelData(ch)[i] )); view.setInt16(offset, sample < 0 ? sample*0x8000 : sample*0x7FFF, true); offset+=2 } }
      return new Blob([view],{type:'audio/wav'});
    }

    // --- Event wiring & interactions ---
    function initControls(){
      document.getElementById('playBtn').addEventListener('click', startSequencer);
      document.getElementById('stopBtn').addEventListener('click', stopSequencer);
      const bpmSlider = document.getElementById('bpmSlider'); const bpmInput = document.getElementById('bpmInput');
      const debouncedBpm = debounce((v)=>{ bpm = parseInt(v) || 120; document.getElementById('bpmSlider').value=bpm; document.getElementById('bpmInput').value=bpm; if(isPlaying){ stopSequencer(); startSequencer(); } autosave(); }, 250);
      bpmSlider.addEventListener('input', (e)=>debouncedBpm(e.target.value)); bpmInput.addEventListener('input', (e)=>debouncedBpm(e.target.value));

      document.getElementById('songLengthInput').addEventListener('input', (e)=>{ songLength = parseInt(e.target.value)||4; autosave(); });
      document.getElementById('swingSlider').addEventListener('input', (e)=>{ swing = parseInt(e.target.value); autosave(); });
      document.getElementById('drumVol').addEventListener('input', (e)=>{ if(nodes.drum.gain) nodes.drum.gain.gain.value = parseFloat(e.target.value); document.getElementById('mixerDrum').value = e.target.value; autosave(); });
      document.getElementById('pianoVol').addEventListener('input',(e)=>{ if(nodes.piano.gain) nodes.piano.gain.gain.value = parseFloat(e.target.value); document.getElementById('mixerPiano').value=e.target.value; autosave(); });
      document.getElementById('bassVol').addEventListener('input',(e)=>{ if(nodes.bass.gain) nodes.bass.gain.gain.value = parseFloat(e.target.value); document.getElementById('mixerBass').value=e.target.value; autosave(); });
      document.getElementById('guitarVol').addEventListener('input',(e)=>{ if(nodes.guitar.gain) nodes.guitar.gain.gain.value = parseFloat(e.target.value); document.getElementById('mixerGuitar').value=e.target.value; autosave(); });

      ['mixerDrum','mixerPiano','mixerBass','mixerGuitar'].forEach(id=>{ document.getElementById(id).addEventListener('input',(e)=>{ const name = id.replace('mixer','').toLowerCase(); if(nodes[name] && nodes[name].gain) nodes[name].gain.gain.value = parseFloat(e.target.value); autosave(); }); });
      ['panDrum','panPiano','panBass','panGuitar'].forEach(id=>{ document.getElementById(id).addEventListener('input',(e)=>{ const name = id.replace('pan','').toLowerCase(); if(nodes[name] && nodes[name].pan) nodes[name].pan.pan.value = parseFloat(e.target.value); autosave(); }); });

      document.getElementById('clearDrum').addEventListener('click', ()=>{ clearPattern(drumPattern); autosave(); }); document.getElementById('clearPiano').addEventListener('click', ()=>{ clearPattern(pianoPattern); autosave(); }); document.getElementById('clearBass').addEventListener('click', ()=>{ clearPattern(bassPattern); autosave(); }); document.getElementById('clearGuitar').addEventListener('click', ()=>{ clearPattern(guitarPattern); autosave(); });

      document.getElementById('saveBtn').addEventListener('click', saveTrack);
      document.getElementById('loadBtn').addEventListener('click', loadTrackList);
      document.getElementById('recordBtn').addEventListener('click', exportWav);

      // keyboard: space toggles play/stop
      window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); if(isPlaying) stopSequencer(); else startSequencer(); } });
    }

    function clearPattern(pattern){ pattern.forEach(row=>row.fill(false)); renderAllGrids(); }

    // debounce util
    function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }}

    // --- initialize ---
    function setup(){ loadAutosave(); renderAllGrids(); initControls(); // connect nodes when user interacts
      // lazily ensureAudioContext on first user gesture to comply with browsers
      const resume = ()=>{ ensureAudioContext(); // connect node references
        ['drum','piano','bass','guitar'].forEach(name=>{ if(!nodes[name].gain){ nodes[name].gain = audioCtx.createGain(); nodes[name].gain.gain.value = parseFloat(document.getElementById('mixer'+capitalize(name)).value || 0.7); nodes[name].gain.connect(audioCtx.destination); nodes[name].pan = audioCtx.createStereoPanner(); nodes[name].pan.connect(nodes[name].gain); }});
        document.removeEventListener('click', resume); document.removeEventListener('keydown', resume);
      };
      document.addEventListener('click', resume);
      document.addEventListener('keydown', resume);

      // labels capitalized for mixer
      function cap(name){return name.charAt(0).toUpperCase()+name.slice(1);} window.capitalize = cap;
    }

    // start
    setup();

  </script>
</body>
</html>
